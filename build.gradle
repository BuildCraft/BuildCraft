// DON'T TOUCH THE BUILDSCRIPT[] BLOCK
// its special, and it is only there to make ForgeGradle work correctly.

buildscript {
    repositories {
        mavenCentral()
        maven {
            name = "forge"
            url = "http://files.minecraftforge.net/maven"
        }
        maven {
            name = "a Russian forum post told me to use this to find the missing files"
            url = "https://repo.spongepowered.org/repository/forge-proxy/"
        }
        maven {
            name = "sonatype"
            url = "https://oss.sonatype.org/content/repositories/snapshots/"
        }
        maven {
            url = "https://jitpack.io"
        }
        maven {
            url = "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        classpath 'com.github.CDAGaming:ForgeGradle:1c670759c5'
    }
}

apply plugin: 'forge' // adds the forge dependency
apply plugin: 'maven' // for uploading to a maven repo
apply plugin: 'checkstyle'

version = "7.1.24"
group= "com.mod-buildcraft"
archivesBaseName = "buildcraft" // the name that all artifacts will use as a base. artifacts names follow this pattern: [baseName]-[appendix]-[version]-[classifier].[extension]

ext.mcModInfo = new groovy.json.JsonSlurper().parse(file("buildcraft_resources/mcmod.info"))
ext.priv = parseConfig(file('private.properties'))

minecraft {
    version = "1.7.10-10.13.4.1614-1.7.10" // McVersion-ForgeVersion     this variable is later changed to contain only the MC version, while the apiVersion variable is used for the forge version.  Yeah its stupid, and will be changed eentually.

    runDir = "run" // the directory for ForgeGradle to run Minecraft in

    // replacing stuff in the source
    replace '@VERSION@', project.version
    replace '@MC_VERSION@', version
}

// configure  the source folders
sourceSets {
    main {
        java {
            srcDir 'common'
            // exclude 'some exclusion'
            // include 'some inclusion'
        }
        resources {
            srcDir 'buildcraft_resources'
            def l10n = file('../BuildCraft-Localization')
            if(l10n.exists())
                srcDir l10n
            exclude '**/.md' // exclude readme from localization repo
            // exclude 'some exclusion'
            // include 'some inclusion'
        }
    }
    api {
		java {
			srcDir 'api'
		}
    }
}

// Obfuscated Jar location
ext.jarFile = zipTree(jar.archivePath)

// Add API dir to the IDEA module
idea.module.sourceDirs += sourceSets.api.java.srcDirs

processResources
{
    // replace stuff in mcmod.info, nothing else
    from(sourceSets.main.resources.srcDirs) {
        include 'mcmod.info'
                
        // replace version and mcversion
        // ${version}   and    ${mcversion}    are the exact strings being replaced
        expand 'version':project.version, 'mcversion':project.minecraft.version
    }
        
    // copy everything else, that's not the mcmod.info
    from(sourceSets.main.resources.srcDirs) {
        exclude 'mcmod.info'
    }
}

// --------------------
// extra jar section
// -------------------



def createMCModInfo(def id, def taskName)
{
    File temp = new File("build/processing/" + taskName + "/mcmod.info")
    temp.parentFile.mkdirs()
    if (temp.exists())
        temp.delete()
    temp.createNewFile()
    temp.write(groovy.json.JsonOutput.toJson([ext.mcModInfo[id]]))
    temp.deleteOnExit()
    return temp
}

def parseConfig(File config) {
    if (!config.exists())
        return null;
    config.withReader {
        def prop = new Properties()
        prop.load(it)
        return (new ConfigSlurper().parse(prop))
    }
}

// add a source jar
task sourceJar(type: Jar) {
    from sourceSets.main.allSource
    from sourceSets.api.allSource
    classifier = 'sources'
}

// add api classes to javadoc
// javadoc {
//     source += sourceSets.api.allSource
// }

// add a javadoc jar
// task javadocJar(type: Jar, dependsOn: javadoc) {
//     classifier = 'javadoc'
//     from 'build/docs/javadoc'
// }

// because the normal output has been made to be obfuscated
task deobfJar(type: Jar) {
    from sourceSets.main.output
    from sourceSets.api.output
    classifier = 'dev'
}

task apiJar(type: Jar) {
    from sourceSets.api.output
    classifier = 'api'
}

task coreJar(type: Jar, dependsOn: reobf) {

    destinationDir = file("modules")
    classifier = 'core'

    doFirst {
        from(createMCModInfo(0, name).parentFile)
        from(project.ext.jarFile) {
            includes.addAll(["assets/buildcraft/**", "assets/buildcraftcore/**", "buildcraft/BuildCraftCore**", "buildcraft/BuildCraftMod**", "buildcraft/core/**", "buildcraft/api/**", "cofh/**", "changelog/**", "LICENSE**", "versions.txt"])
        }
    }
}

task buildersJar(type: Jar, dependsOn: reobf) {

    destinationDir = file("modules")
    classifier = 'builders'

    doFirst {
        from(createMCModInfo(1, name).parentFile)
        from(project.ext.jarFile) {
            includes.addAll(["assets/buildcraftbuilders/**", "buildcraft/builders/**", "buildcraft/BuildCraftBuilders**", "LICENSE"])
        }
    }
}

task energyJar(type: Jar, dependsOn: reobf) {

    destinationDir = file("modules")
    classifier = 'energy'

    doFirst {
        from(createMCModInfo(2, name).parentFile)
        from(project.ext.jarFile) {
            includes.addAll(["assets/buildcraftenergy/**", "buildcraft/energy/**", "buildcraft/BuildCraftEnergy**", "LICENSE"])
        }
    }
}

task factoryJar(type: Jar, dependsOn: reobf) {

    destinationDir = file("modules")
    classifier = 'factory'

    doFirst {
        from(createMCModInfo(3, name).parentFile)
        from(project.ext.jarFile) {
            includes.addAll(["assets/buildcraftfactory/**", "buildcraft/factory/**", "buildcraft/BuildCraftFactory**", "LICENSE"])
        }
    }
}

task siliconJar(type: Jar, dependsOn: reobf) {

    destinationDir = file("modules")
    classifier = 'silicon'

    doFirst {
        from(createMCModInfo(4, name).parentFile)
        from(project.ext.jarFile) {
            includes.addAll(["assets/buildcraftsilicon/**", "buildcraft/silicon/**", "buildcraft/BuildCraftSilicon**", "LICENSE"])
        }
    }
}

task transportJar(type: Jar, dependsOn: reobf) {

    destinationDir = file("modules")
    classifier = 'transport'

    doFirst {
        from(createMCModInfo(5, name).parentFile)
        from(project.ext.jarFile) {
            includes.addAll(["assets/buildcrafttransport/**", "buildcraft/transport/**", "buildcraft/BuildCraftTransport**", "LICENSE"])
        }
    }
}

task roboticsJar(type: Jar, dependsOn: reobf) {

    destinationDir = file("modules")
    classifier = 'robotics'

    doFirst {
        from(createMCModInfo(6, name).parentFile)
        from(project.ext.jarFile) {
            includes.addAll(["assets/buildcraftrobotics/**", "buildcraft/robotics/**", "buildcraft/BuildCraftRobotics**", "LICENSE"])
        }
    }
}


// add api classes to main package
jar {
	from sourceSets.api.output
}

checkstyle {
	configFile = file('guidelines/buildcraft.checkstyle')
}

checkstyleApi.exclude 'cofh/**'

// make sure all of these happen when we run build
build.dependsOn sourceJar, deobfJar, apiJar
